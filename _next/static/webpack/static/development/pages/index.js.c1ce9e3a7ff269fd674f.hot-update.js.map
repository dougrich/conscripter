{"version":3,"file":"static/webpack/static/development/pages/index.js.c1ce9e3a7ff269fd674f.hot-update.js","sources":["webpack:///./state/reducers/fonts/parsePath.js"],"sourcesContent":["const DEGREES_TO_RADIANS = 0.0174533\nconst SNAPPING_RATIO = 1 / 400\n\nfunction basis(t, count) {\n  const w = new Array(count) \n  for (let i = 0; i < count; i++) {\n    const factor = (i === 0 || i === count - 1)\n      ? 1\n      : (count - 1)\n    w[i] =  factor * Math.pow((1 - t), count - 1 - i) * Math.pow(t, i)\n  }\n  return function () {\n    let v = 0\n    for (let i = 0; i < count; i++) {\n      v += arguments[i] * w[i]\n    }\n    return v\n  }\n}\n\nfunction cubicInterpolation(x0, y0, x1, y1, x2, y2, x3, y3) {\n  const commands = []\n  for (let t = 0.1; t < 1; t += 0.06) {\n    const apply = basis(t, 4)\n    commands.push({\n      type: 'L',\n      x: apply(x0, x1, x2, x3),\n      y: apply(y0, y1, y2, y3)\n    })\n  }\n  // this ensures we end at the exact end point\n  commands.push({\n    type: 'L',\n    x: x3,\n    y: y3\n  })\n\n  return commands\n}\n\nclass PathParser {\n  constructor (\n    config,\n    parse5 = require('parse5'),\n    svgPathParser = require('svg-path-parser'),\n    svgTransformParser = require('svg-transform-parser'),\n    arcToBezier = require('svg-arc-to-cubic-bezier')\n  ) {\n    this.config = config\n    this.parse5 = parse5\n    this.svgPathParser = svgPathParser\n    this.svgTransformParser = svgTransformParser\n    this.arcToBezier = arcToBezier.default || arcToBezier\n  }\n\n  parseTransform(transform) {\n    const detail = this.svgTransformParser.parse(transform)\n\n    return (node) => {\n      const { type, x, y } = node\n      if (detail.translate) {\n        const { tx = 0, ty = 0} = detail.translate\n        return {\n          type,\n          x: tx + x,\n          y: ty + y\n        }\n      }\n\n      if (detail.matrix) {\n        const { a, b, c, d, e, f } = detail.matrix\n        return {\n          type,\n          x: a * x + c * y + e,\n          y: b * x + d * y + f\n        }\n      }\n\n      if (detail.rotate) {\n        const { angle, cx = 0, cy = 0 } = detail.rotate\n        const radians = angle * DEGREES_TO_RADIANS\n        const sine = Math.sin(radians)\n        const cosine = Math.cos(radians)\n        const dx = x - cx\n        const dy = y - cy\n        return {\n          type,\n          x: cosine * dx - sine * dy + cx,\n          y: sine * dx + cosine * dy + cy\n        }\n      }\n\n      if (detail.scale) {\n        const { sx, sy = sx} = detail.scale\n        return {\n          type,\n          x: sx * x,\n          y: sy * y\n        }\n      }\n    }\n  }\n\n  applyTransforms(transforms = [], node) {\n    for (let i = transforms.length - 1; i >= 0; i--) {\n      const t = transforms[i]\n      node = t(node)\n    }\n    return node\n  }\n\n  attributes(node) {\n    const attributes = {}\n    if (node.attrs) {\n      for (const attr of node.attrs) {\n        attributes[attr.name] = attr.value\n      }\n    }\n    return attributes\n  }\n\n  createCommand(cmd, i, arr) {\n    if (cmd.code === 'S') {\n      let { x: x0, y: y0, x2: x1, y2: y1 } = arr[i - 1]\n      const { x2, y2, x, y } = cmd\n      if (x1 == y1 && x1 == null) {\n        x1 = x0\n        y1 = y0\n      } else {\n        x1 = (x0 - x1) + x0\n        y1 = (y0 - y1) + y0\n      }\n      cmd = {\n        code: 'C',\n        x1,\n        x2,\n        y1,\n        y2,\n        x,\n        y\n      }\n    }\n\n    if (cmd.code === 'A') {\n      const { rx, ry, xAxisRotation, largeArc, sweep, x, y, x0, y0 } = cmd\n      const curves = this.arcToBezier({\n        px: x0,\n        py: y0,\n        cx: x,\n        cy: y,\n        rx,\n        ry,\n        xAxisRotation,\n        largeArcFlag: largeArc ? 1 : 0,\n        sweepFlag: sweep ? 1 : 0\n      })\n      const commands = []\n      let xlast = x0, ylast = y0\n      for (let i = 0; i < curves.length; i++) {\n        const { x1, y1, x2, y2, x: x3, y: y3 } = curves[i]\n        commands.push(...cubicInterpolation(xlast, ylast, x1, y1, x2, y2, x3, y3))\n        xlast = x3\n        ylast = y3\n      }\n      return commands\n    }\n\n    if (cmd.code === 'C') {\n      const { x: x0, y: y0 } = arr[i - 1]\n      const { x: x3, y: y3, x1, x2, y1, y2 } = cmd\n      // interpolate - note we skip the start as it should be drawn from the previous node\n      return cubicInterpolation(x0, y0, x1, y1, x2, y2, x3, y3)\n    }\n\n    if (cmd.code === 'Q') {\n      const { x0, y0, x1, y1, x, y } = cmd\n      // interpolate - note we skip the start as it should be drawn from the previous node\n      const commands = []\n      for (let t = 0.1; t < 1; t += 0.06) {\n        const apply = basis(t, 3)\n        commands.push({\n          type: 'L',\n          x: apply(x0, x1, x),\n          y: apply(y0, y1, y)\n        })\n      }\n      // this ensures we end at the exact end point\n      commands.push({\n        type: 'L',\n        x,\n        y\n      })\n\n      return commands\n    }\n\n    return {\n      type: {\n        'H': 'L',\n        'V': 'L'\n      }[cmd.code] || cmd.code,\n      x: cmd.x,\n      y: cmd.y\n    }\n  }\n\n  parseChild(node, commands, warnings, transforms = []) {\n    const attributes = this.attributes(node)\n\n    if (attributes.transform) {\n      transforms = [...transforms, this.parseTransform(attributes.transform)]\n    }\n\n    if (node.nodeName === 'path') {\n      // it is a path: pull out the critical attribute\n      if (attributes['fill-opacity'] != null) {\n        const opacity = parseFloat(attributes['fill-opacity'])\n        if (opacity === 0) {\n          return\n        } else {\n          warnings.push(PathParser.Codes.WarnTranslucentFill)\n        }\n      }\n      if (attributes.d) {\n        const d = attributes.d\n        const subCommands = this.svgPathParser.makeAbsolute(this.svgPathParser.parseSVG(d))\n        commands.push(...subCommands\n          .map((cmd, i, arr) => this.createCommand(cmd, i, arr))\n          .reduce((set, v) => Array.isArray(v) ? [...set, ...v] : [...set, v], [])\n          .map(cmd => this.applyTransforms(transforms, cmd))\n          .map((cmd, i, arr) => {\n            if (cmd.x === arr[0].x && cmd.y === arr[0].y && i === arr.length - 1) {\n              return { type: 'Z' }\n            } else {\n              return cmd\n            }\n          }))\n        if (commands[commands.length - 1].type !== 'Z') {\n          commands.push({ type: 'Z' })\n        }\n      }\n\n      if (attributes.fill) {\n        const fill = attributes.fill\n        if (fill === 'transparent') {\n          warnings.push(PathParser.Codes.WarnEmptyFill)\n        } else if (!/^#([0-9a-fA-F]){3,6}$/gi.test(fill)) {\n          warnings.push(PathParser.Codes.WarnComplexFill)\n        }\n      }\n\n      if (attributes.stroke) {\n        const stroke = attributes.stroke\n        if (stroke !== 'transparent') {\n          warnings.push(PathParser.Codes.WarnNonEmptyStroke)\n        }\n      }\n    }\n\n    if (node.nodeName === 'rect') {\n      const { width, height, x = '0', y = '0' } = attributes\n      const widthF = parseFloat(width)\n      const heightF = parseFloat(height)\n      const xF = parseFloat(x)\n      const yF = parseFloat(y)\n      const subCommands = [\n        { type: 'M', x: xF, y: yF },\n        { type: 'L', x: xF + widthF, y: yF },\n        { type: 'L', x: xF + widthF, y: yF + heightF },\n        { type: 'L', x: xF, y: yF + heightF },\n        { type: 'Z' }\n      ]\n      commands.push(...subCommands.map(cmd => this.applyTransforms(transforms, cmd)))\n    }\n\n    if (node.nodeName === 'circle') {\n      const { cx, cy, r } = attributes\n      const cxF = parseFloat(cx)\n      const cyF = parseFloat(cy)\n      const rF = parseFloat(r)\n      const subCommands = [\n        { type: 'M', x: cxF + rF, y: cyF }\n      ]\n      const incr = 0.076 * Math.PI\n      for (let i = incr; i < Math.PI * 2; i += incr) {\n        subCommands.push({\n          type: 'L', x: cxF + Math.cos(i) * rF, y: cyF + Math.sin(i) * rF\n        })\n      }\n      subCommands.push({ type: 'Z' })\n      commands.push(...subCommands.map(cmd => this.applyTransforms(transforms, cmd)))\n    }\n\n    if (node.nodeName === 'g') {\n      for (const childNode of node.childNodes) {\n        this.parseChild(childNode, commands, warnings, transforms)\n      }\n    }\n  }\n\n  findSvgNode(tree) {\n    if (tree.nodeName === 'svg') {\n      return tree\n    }\n    \n    if (!tree.childNodes) {\n      return null\n    }\n\n    for (let i = 0; i < tree.childNodes.length; i++) {\n      const svg = this.findSvgNode(tree.childNodes[i])\n      if (svg) return svg\n    }\n\n    return null\n  }\n\n  simplify(commands) {\n    const snapTo = this.config.unitsPerEm * SNAPPING_RATIO\n    return commands\n      .map(cmd => ({\n        ...cmd,\n        x: cmd.x ? Math.round(cmd.x / snapTo) : cmd.x,\n        y: cmd.y ? Math.round(cmd.y / snapTo) : cmd.y,\n      }))\n      .filter((cmd, i, arr) => {\n        if (i === 0) return true\n        const previous = arr[i - 1]\n        return previous.x !== cmd.x || previous.y !== cmd.y\n      })\n      .map(cmd => ({\n        ...cmd,\n        x: cmd.x ? cmd.x * snapTo : cmd.x,\n        y: cmd.y ? cmd.y * snapTo : cmd.y,\n      }))\n  }\n\n  /**\n   * Parses a SVG document into a series of path commands\n   * @param {string} svg contents to be parse\n   * @returns {{ commands: opentype.PathCommand[]; warnings: { code: string; message: string; }[] }} commands for open type and a list of warning codes: see PathParser.Codes\n   */\n  parse(svg) {\n    const tree = this.parse5.parse(svg)\n    const svgNode = this.findSvgNode(tree)\n\n    if (!svgNode) {\n      throw new PathParser.Codes.ErrorNoSVGNode()\n    }\n\n    let commands = []\n    let warnings = []\n\n    for (const childNode of svgNode.childNodes) {\n      this.parseChild(childNode, commands, warnings)\n    }\n\n    const {\n      unitsPerEm,\n      descender\n    } = this.config\n\n    // scale commands\n    let scale = 1.0\n    const attributes = this.attributes(svgNode)\n\n    if (attributes.height) {\n      scale = unitsPerEm / parseFloat(attributes.height)\n    }\n\n    if (attributes.viewBox) {\n      scale = unitsPerEm / parseFloat(attributes.viewBox.split(' ')[3])\n    }\n\n    for (const cmd of commands) {\n      if (cmd.x) cmd.x = cmd.x * scale\n      if (cmd.y) cmd.y = (unitsPerEm - cmd.y * scale) + descender\n    }\n\n    warnings = warnings.filter((x, i, arr) => arr.indexOf(x) === i)\n\n    return { commands, warnings }\n  }\n}\n\nPathParser.Codes = {\n  ErrorNoSVGNode: class extends Error {\n    constructor() {\n      super('Could not find the root SVG node - is this a well-formated SVG document?')\n      this.code === 'ErrorNoSVGNode'\n    }\n  },\n  WarnEmptyFill: {\n    code: 'WarnEmptyFill',\n    message: 'One or more paths have an empty fill, which can have unexpected results. Ensure all shapes have a solid fill and no stroke.'\n  },\n  WarnComplexFill: {\n    code: 'WarnComplexFill',\n    message: 'One or more paths have a fill that is not a solid flat color, which can have unexpected results. Ensure all shapes have a solid fill and no stroke.'\n  },\n  WarnNonEmptyStroke: {\n    code: 'WarnNonEmptyStroke',\n    message: 'One or more paths have a non-empty stroke, which can have unexpected results. Ensure all shapes have a solid fill and no stroke.'\n  }\n}\n\nmodule.exports = PathParser"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;;;AACA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;;;AAEA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AAAA;AACA;;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AANA;AAQA;;;AAEA;AAAA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AADA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAHA;AAAA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAHA;AAAA;AAKA;AAEA;;;;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAAA;AAAA;AACA;AADA;AAWA;AAAA;AACA;AACA;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AADA;AAAA;AAAA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;AACA;AA+BA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;;;;;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AADA;AACA;AACA;AAFA;AAGA;AACA;AALA;AAAA;AAMA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAfA;AAqBA;;;;A","sourceRoot":""}